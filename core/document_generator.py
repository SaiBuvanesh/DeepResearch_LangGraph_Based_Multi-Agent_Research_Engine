import markdown
import re
from docx import Document
from pptx import Presentation
from pptx.enum.text import PP_ALIGN
from pptx.dml.color import RGBColor
from docx2pdf import convert
from pptx.util import Inches, Pt
from markdown import markdown
from bs4 import BeautifulSoup

class Generator:
    def __init__(self):
        # self.content = content
        self.docx_path = "Document/Report.docx"
        self.pdf_path = "Document/Report.pdf"
        self.pptx_path = "Document/Report.pptx"

    def generate_doc(self, content):
        html = markdown(content)
        plain_text = re.sub('<[^<]+?>', '', html)

        doc = Document()
        for line in plain_text.split('\n'):
            line = line.strip()
            if line:
                doc.add_paragraph(line)
        
        doc.save(self.docx_path)
        return self.docx_path
        print("✅ DOCX saved!")
        

    def generate_pdf(self, content):
        import pythoncom
        pythoncom.CoInitialize()
        try:
            self.generate_doc(content=content)
            convert(self.docx_path, self.pdf_path)
        finally:
            pythoncom.CoUninitialize()
        return self.pdf_path
        print("✅ PDF created!")

    def generate_pptx(self, content):
        html = markdown(content)
        soup = BeautifulSoup(html, "html.parser")

        prs = Presentation()
        blank_slide_layout = prs.slide_layouts[6]

        slide = prs.slides.add_slide(prs.slide_layouts[0])
        if slide.shapes.title:
            slide.shapes.title.text = "AI Research Report"
        if len(slide.placeholders) > 1:
            subtitle = slide.placeholders[1]
            if subtitle and subtitle.text_frame:
                subtitle.text_frame.text = "Generated by LangGraph Research Agent"

        def auto_chunk(paragraphs, max_chars=1000):
            def split_paragraph(para, limit):
                if len(para) <= limit:
                    return [para]
                words = para.split()
                chunks, current, current_len = [], [], 0
                for word in words:
                    if current_len + len(word) + 1 > limit:
                        chunks.append(" ".join(current))
                        current = [word]
                        current_len = len(word)
                    else:
                        current.append(word)
                        current_len += len(word) + 1
                if current:
                    chunks.append(" ".join(current))
                return chunks

            final_chunks = []
            current_chunk = []
            current_len = 0

            for para in paragraphs:
                print("Paragraph: ", para, "\n")
                sub_chunks = split_paragraph(para, max_chars)
                for sub in sub_chunks:
                    if current_len + len(sub) > max_chars:
                        if current_chunk:
                            final_chunks.append(current_chunk)
                        current_chunk = [sub]
                        current_len = len(sub)
                    else:
                        current_chunk.append(sub)
                        current_len += len(sub)

            if current_chunk:
                final_chunks.append(current_chunk)

            return final_chunks

        for section in soup.find_all(["h1", "h2"]):
            title = section.get_text().strip()
            content = []
            next_node = section.find_next_sibling()
            while next_node and next_node.name not in ["h1", "h2"]:
                para_text = next_node.get_text().strip()
                if para_text:
                    content.append(para_text)
                next_node = next_node.find_next_sibling()

            if not content:
                continue

            is_sources = title.lower() in ["sources", "references"]
            char_limit = 1500 if is_sources else 1300
            i = 0
        
            chunked_paragraph_lists = auto_chunk(content, max_chars=char_limit)
            print("After auto chunk: ", chunked_paragraph_lists, "\n")
        
            for i, paragraph_list in enumerate(chunked_paragraph_lists):
                slide = prs.slides.add_slide(blank_slide_layout)

            
                left = Inches(0.5)
                top = Inches(0.5)
                width = Inches(9)
                height = Inches(9)

                textbox = slide.shapes.add_textbox(left, top, width, height)
                tf = textbox.text_frame
                tf.word_wrap = True
                tf.clear()  #

            
                if i == 0:
                    title_para = tf.paragraphs[0]
                    title_para.text = title
                    title_para.font.bold = True
                    title_para.alignment = PP_ALIGN.CENTER 
                    title_para.font.size = Pt(24 if is_sources else 28)
                    title_para.font.color.rgb = RGBColor(0x2E, 0x74, 0xB5)

                    spacer = tf.add_paragraph()
                    spacer.text = ""
                    spacer.space_after = Pt(30)

            
                max_bullets = 14
                font_size = Pt(14 if is_sources or len(paragraph_list) > max_bullets else 18)

                for para in paragraph_list:
                    bullet = tf.add_paragraph()
                    bullet.text = para
                    bullet.level = 0
                    bullet.font.size = font_size
                    bullet.font.color.rgb = RGBColor(0, 0, 0)
                    bullet.font.bold = False
                    bullet.bullet = True
                    bullet.space_after = Pt(20)

        prs.save(self.pptx_path)
        return self.pptx_path
        print(f"✅ Presentation saved as {self.pptx_path}")
